# frozen_string_literal: true

module Rubcask
  # Rubcask protocol is inspired by Redis, but is even simpler implementation-wise
  # The format of response is
  #   "#{message.byte_size}"\r\n#{message}
  #   eg: "2\r\nOK"
  # The format of request it is
  #   "#{message.byte_size}\r\n#{method}\r\n#{first_argument.byte_size}\r\n#{first_argument}
  #   eg: "13\r\nget\r\n5\r\nlorem"
  module Protocol
    # Success
    OK = "ok"

    # Repesents no data
    NIL = "nil"

    # Error message
    ERROR = "error"

    PING = "ping"
    PONG = "pong"

    SEPARATOR = "\r\n"

    module_function

    # Returns the provided message with the header of the start
    # @param [String] message Message to encode
    # @return [String]
    def encode_message(message)
      buffer = (+"").b
      buffer << message.bytesize.to_s
      buffer << SEPARATOR
      buffer << message
      buffer
    end

    # @param [String] method Name of the method
    # @param [Array<String>] args method arguments
    # @return [String]
    def create_call_message(method, *args)
      buffer = (+"").b
      buffer << method
      buffer << SEPARATOR
      args.each do |arg|
        buffer << encode_message(arg)
      end

      encode_message(buffer)
    end

    class << self
      private

      # @!macro [attach] generate_cached_message
      #   @method $1_message
      #   @note This method is autogenerated
      #   @return [String] Encoded "$1" messege.
      def generate_cached_message(method)
        value = encode_message(const_get(method.upcase)).freeze
        define_method "#{method}_message" do
          value
        end
      end
    end

    generate_cached_message "ok"
    generate_cached_message "nil"
    generate_cached_message "error"
    generate_cached_message "ping"
    generate_cached_message "pong"
  end
end
